<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PodViewer Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Arabic:wght@400;700&family=Inter:wght@400;700&family=Playfair+Display:wght@700&family=Poppins:wght@500&family=Roboto+Slab:wght@400&family=Source+Code+Pro&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        .player-wrapper {
            transition: all 0.5s ease-in-out;
        }
        .editor-wrapper {
             transition: all 0.5s ease-in-out;
        }
        .player-container {
            background-color: #111827;
            position: relative;
            z-index: 10;
        }
        .player-container::before {
            content: "";
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiGAAAAA3NCSVQICAjb4U/gAAAAMFBMVEX///9ISEhHR0dJSUlKSkpMTExNTU1OTk5QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1eAgIAn5TceAAAAD3RSTlMAAQIDBAUGBwgJCgsMDQ4PEO2GfAAAAElJREFUSImNycWSAwAAMAzCNp7/f1pqOSA71xceD8vW1lZXV1dZWVk/nJKSkpKSkpOTk5eXl5eXl5eXl5eXl5eXl5dXTg8A93o59gAAAABRU5ErkJggg==');
            opacity: 0.05;
            pointer-events: none;
            z-index: 15;
        }
        .text-dim { opacity: 0.4; transition: opacity 0.3s ease-in-out; }
        .is-highlighted { opacity: 1; transition: opacity 0.3s ease-in-out; }
        [contenteditable] { cursor: pointer; }
        [contenteditable]:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(168, 85, 247, 0.5);
            border-radius: 4px;
        }
        #editable-title:empty::before {
            content: '[Click to Edit Title]';
            color: rgba(255, 255, 255, 0.4);
            font-style: italic;
            pointer-events: none;
        }
        .button-label {
            max-width: 0;
            opacity: 0;
            transition: max-width 0.4s ease-out, opacity 0.2s ease-in;
            white-space: nowrap;
            overflow: hidden;
        }
        .group:hover .button-label { max-width: 100px; opacity: 1; }
        [dir="ltr"] .group:hover .button-label { margin-left: 0.5rem; }
        [dir="rtl"] .group:hover .button-label { margin-right: 0.5rem; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #a855f7; cursor: pointer; border-radius: 9999px; }
        input[type=range]::-moz-range-thumb { width: 16px; height: 16px; background: #a855f7; cursor: pointer; border-radius: 9999px; border: 0;}
        
        /* --- VS Code Editor Theme --- */
        #monacoEditorContainer {
            background-color: #1e1e1e;
        }

        /* Monaco must stay LTR or it will vanish when parent is RTL */
        #monacoEditorContainer,
        #monacoEditorContainer .monaco-editor,
        #monacoEditorContainer .monaco-editor .view-lines {
            direction: ltr !important;
            /* Added for correct caret behavior with RTL text inside LTR container */
            unicode-bidi: plaintext;
        }

        /* Ensure editor control buttons are clickable and on top */
        #advancedModePanel .flex-shrink-0 button,
        #advancedModePanel .flex-shrink-0 label {
            pointer-events: auto !important;
            z-index: 20; 
        }

        /* --- Kinetic Word Effects (triggered by .is-highlighted) --- */
        .is-highlighted.fx-shake { animation: shake 0.5s; }
        .is-highlighted.fx-pulse { animation: pulse 0.8s; }
        .is-highlighted.fx-wave span { display: inline-block; animation: wave-letter 1.2s ease-in-out; }
        .is-highlighted.fx-zoom-in { animation: zoom-in 0.4s ease-out; }
        .is-highlighted.fx-slide-up { animation: slide-up 0.5s ease-out; }
        .is-highlighted.fx-glitch { animation: glitch 0.4s; }
        .is-highlighted.fx-fade-in { animation: fade-in 0.5s ease-out; }
        
        /* --- NEW EFFECTS FROM IDEAS.MD --- */
        .is-highlighted.fx-burst { 
            position: relative;
            animation: fade-in 0.3s ease-out;
        }
        .is-highlighted.fx-burst::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: currentColor;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: particle-burst 0.6s ease-out forwards;
            box-shadow: 
                0 0 0 0 currentColor,
                10px 5px 0 0 currentColor,
                -8px 12px 0 0 currentColor,
                15px -10px 0 0 currentColor,
                -12px -8px 0 0 currentColor,
                20px 0px 0 0 currentColor,
                -15px 0px 0 0 currentColor;
        }
        
        .is-highlighted.fx-rgb-glitch { 
            animation: rgb-glitch 0.4s ease-in-out;
        }
        
        .is-highlighted.fx-emoji-rain {
            position: relative;
            animation: fade-in 0.3s ease-out;
        }
        .is-highlighted.fx-emoji-rain::before {
            content: '🔥';
            position: absolute;
            top: -50px;
            left: 50%;
            width: 2px;
            height: 2px;
            color: transparent;
            font-size: 20px;
            animation: emoji-storm-1 3s linear infinite;
            pointer-events: none;
            z-index: 10;
            box-shadow: 
                -100px 0 0 0 currentColor, -80px 0 0 0 currentColor, -60px 0 0 0 currentColor, -40px 0 0 0 currentColor, -20px 0 0 0 currentColor,
                0px 0 0 0 currentColor, 20px 0 0 0 currentColor, 40px 0 0 0 currentColor, 60px 0 0 0 currentColor, 80px 0 0 0 currentColor, 100px 0 0 0 currentColor,
                -90px 20px 0 0 currentColor, -70px 20px 0 0 currentColor, -50px 20px 0 0 currentColor, -30px 20px 0 0 currentColor, -10px 20px 0 0 currentColor,
                10px 20px 0 0 currentColor, 30px 20px 0 0 currentColor, 50px 20px 0 0 currentColor, 70px 20px 0 0 currentColor, 90px 20px 0 0 currentColor,
                -110px 40px 0 0 currentColor, -85px 40px 0 0 currentColor, -65px 40px 0 0 currentColor, -45px 40px 0 0 currentColor, -25px 40px 0 0 currentColor,
                -5px 40px 0 0 currentColor, 15px 40px 0 0 currentColor, 35px 40px 0 0 currentColor, 55px 40px 0 0 currentColor, 75px 40px 0 0 currentColor, 95px 40px 0 0 currentColor;
        }
        .is-highlighted.fx-emoji-rain::after {
            content: '🔥';
            position: absolute;
            top: -70px;
            left: 50%;
            width: 2px;
            height: 2px;
            color: transparent;
            font-size: 18px;
            animation: emoji-storm-2 3.5s linear infinite 1s;
            pointer-events: none;
            z-index: 9;
            box-shadow: 
                -95px 10px 0 0 currentColor, -75px 10px 0 0 currentColor, -55px 10px 0 0 currentColor, -35px 10px 0 0 currentColor, -15px 10px 0 0 currentColor,
                5px 10px 0 0 currentColor, 25px 10px 0 0 currentColor, 45px 10px 0 0 currentColor, 65px 10px 0 0 currentColor, 85px 10px 0 0 currentColor,
                -105px 30px 0 0 currentColor, -80px 30px 0 0 currentColor, -60px 30px 0 0 currentColor, -40px 30px 0 0 currentColor, -20px 30px 0 0 currentColor,
                0px 30px 0 0 currentColor, 20px 30px 0 0 currentColor, 40px 30px 0 0 currentColor, 60px 30px 0 0 currentColor, 80px 30px 0 0 currentColor, 100px 30px 0 0 currentColor,
                -115px 50px 0 0 currentColor, -90px 50px 0 0 currentColor, -70px 50px 0 0 currentColor, -50px 50px 0 0 currentColor, -30px 50px 0 0 currentColor,
                -10px 50px 0 0 currentColor, 10px 50px 0 0 currentColor, 30px 50px 0 0 currentColor, 50px 50px 0 0 currentColor, 70px 50px 0 0 currentColor, 90px 50px 0 0 currentColor;
        }
        
        /* Universal emoji rain effect that works with any emoji via CSS custom properties */
        .fx-emoji-rain-universal {
            position: relative;
            animation: fade-in 0.3s ease-out;
        }
        .fx-emoji-rain-universal::before,
        .fx-emoji-rain-universal::after {
            content: var(--emoji, '🔥');
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 10;
            font-size: 20px;
        }
        .fx-emoji-rain-universal::before {
            top: -30px;
            animation: emoji-fall-1 2s linear infinite;
        }
        .fx-emoji-rain-universal::after {
            top: -60px;
            font-size: 18px;
            animation: emoji-fall-2 2.5s linear infinite 0.5s;
            z-index: 9;
        }
        
        .is-highlighted.fx-laser {
            position: relative;
            animation: fade-in 0.3s ease-out;
        }
        .is-highlighted.fx-laser::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: laser-sweep 0.8s ease-out forwards;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .is-highlighted.fx-reveal-circle {
            animation: reveal-circle 0.6s ease-out forwards;
            clip-path: circle(0% at center);
        }
        
        .is-highlighted.fx-confetti {
            position: relative;
            animation: fade-in 0.3s ease-out;
        }
        .is-highlighted.fx-confetti::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            width: 100px;
            height: 100px;
            transform: translateX(-50%);
            background: 
                radial-gradient(circle at 20% 20%, #ff6b6b 2px, transparent 2px),
                radial-gradient(circle at 80% 40%, #4ecdc4 2px, transparent 2px),
                radial-gradient(circle at 40% 80%, #45b7d1 2px, transparent 2px),
                radial-gradient(circle at 60% 20%, #f9ca24 2px, transparent 2px),
                radial-gradient(circle at 20% 60%, #f0932b 2px, transparent 2px);
            background-size: 20px 20px;
            animation: confetti-burst 1s ease-out forwards;
            pointer-events: none;
            z-index: 10;
        }
        
        .is-highlighted.fx-wave-mask {
            background: linear-gradient(90deg, 
                transparent 0%, 
                currentColor 25%, 
                transparent 50%, 
                currentColor 75%, 
                transparent 100%);
            background-size: 200% 100%;
            animation: wave-mask 1s ease-in-out infinite;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        /* Image effects */
        .fx-image-parallax { 
            animation: parallax-pan var(--cue-duration, 3s) linear forwards; 
        }
        .fx-image-edge {
            animation: edge-pop 0.5s ease-out forwards;
            transform-origin: center;
        }
        /* NEW: image appears in the corner and gently bobs as if speaking */
        .fx-image-edge-talk {
            animation: edge-talk 1s ease-in-out infinite;
            transform-origin: bottom center;
        }

        @keyframes edge-talk {
            0% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
            100% { transform: translateY(0); }
        }
        
        /* Background scene switches */
        .bg-matrix {
            background: 
                linear-gradient(90deg, transparent 98%, #00ff00 100%),
                linear-gradient(0deg, transparent 98%, #00ff00 100%);
            background-size: 20px 20px;
            animation: matrix-scroll 2s linear infinite;
        }
        .bg-retro-grid {
            background: 
                linear-gradient(rgba(0,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,255,255,0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: retro-grid-glow 3s ease-in-out infinite alternate;
        }
        
        /* Title hierarchy with decreasing prominence */
        .is-highlighted.fx-title1 { 
            animation: fade-in-drop 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
            font-size: 1.8em !important;
            font-weight: 900 !important;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.05em;
        }
        .is-highlighted.fx-title2 { 
            animation: fade-in-slide 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
            font-size: 1.4em !important;
            font-weight: 700 !important;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .is-highlighted.fx-title3 { 
            animation: fade-in-gentle 0.4s ease-out both;
            font-size: 1.2em !important;
            font-weight: 600 !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .is-highlighted.fx-subline { 
            position: relative;
            animation: fade-in 0.3s ease-out;
        } 
        .is-highlighted.fx-subline::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -4px;
            width: 100%;
            height: 2px;
            background: #a855f7;
            transform: scaleX(0);
            transform-origin: left;
            animation: grow-line 0.5s forwards;
        }
        .is-highlighted.fx-glow { animation: glow 1.5s ease-in-out; }
        .fx-image-slow-zoom-in { animation: slow-zoom-in forwards; }
        .typing-cursor {
            display: inline-block;
            animation: blink 1s step-end infinite;
        }

        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
          20%, 40%, 60%, 80% { transform: translateX(2px); }
        }
        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.15); }
        }
        @keyframes wave-letter {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-5px); }
        }
        @keyframes zoom-in {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes slide-up {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-3px, 3px); }
            40% { transform: translate(3px, -3px); }
            60% { transform: translate(-3px, -3px); }
            80% { transform: translate(3px, 3px); }
            100% { transform: translate(0); }
        }
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes fade-in-drop {
          0% { transform: translateY(-20px); opacity: 0; }
          100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes fade-in-slide {
          0% { transform: translateX(-15px); opacity: 0; }
          100% { transform: translateX(0); opacity: 1; }
        }
        @keyframes fade-in-gentle {
          0% { transform: translateY(-8px); opacity: 0; }
          100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes grow-line {
            to { transform: scaleX(1); }
        }
        @keyframes glow {
            from { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #a855f7, 0 0 20px #a855f7; }
            to { text-shadow: 0 0 10px #fff, 0 0 20px #f472b6, 0 0 30px #f472b6, 0 0 40px #f472b6; }
        }
        @keyframes slow-zoom-in {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }
        @keyframes blink {
            from, to { opacity: 1; }
            50% { opacity: 0; }
        }
        
        /* --- NEW KEYFRAMES FOR IDEAS.MD EFFECTS --- */
        @keyframes particle-burst {
            0% { 
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -50%) scale(3);
                opacity: 0;
            }
        }
        
        @keyframes rgb-glitch {
            0% { 
                transform: translate(0);
                filter: hue-rotate(0deg);
            }
            20% { 
                transform: translate(-2px, 1px);
                filter: hue-rotate(90deg);
            }
            40% { 
                transform: translate(2px, -1px);
                filter: hue-rotate(180deg);
            }
            60% { 
                transform: translate(-1px, 2px);
                filter: hue-rotate(270deg);
            }
            80% { 
                transform: translate(1px, -2px);
                filter: hue-rotate(360deg);
            }
            100% { 
                transform: translate(0);
                filter: hue-rotate(0deg);
            }
        }
        
        @keyframes emoji-storm-1 {
            0% {
                transform: translateY(-50px);
                opacity: 1;
            }
            100% {
                transform: translateY(200px);
                opacity: 0;
            }
        }
        
        @keyframes emoji-storm-2 {
            0% {
                transform: translateY(-70px);
                opacity: 1;
            }
            100% {
                transform: translateY(220px);
                opacity: 0;
            }
        }
        
        @keyframes laser-sweep {
            0% { 
                transform: scaleX(0);
                opacity: 0;
            }
            50% { 
                opacity: 1;
            }
            100% { 
                transform: scaleX(1);
                opacity: 0.3;
            }
        }
        
        @keyframes reveal-circle {
            from { 
                clip-path: circle(0% at center);
            }
            to { 
                clip-path: circle(100% at center);
            }
        }
        
        @keyframes confetti-burst {
            0% { 
                transform: translateX(-50%) scale(0) rotate(0deg);
                opacity: 1;
            }
            50% { 
                transform: translateX(-50%) scale(1.2) rotate(180deg);
                opacity: 0.8;
            }
            100% { 
                transform: translateX(-50%) scale(0.8) rotate(360deg);
                opacity: 0;
            }
        }
        
        @keyframes wave-mask {
            0% { 
                background-position: -200% 0;
            }
            100% { 
                background-position: 200% 0;
            }
        }
        
        @keyframes parallax-pan {
            from { 
                transform: translateX(0);
            }
            to { 
                transform: translateX(-20px);
            }
        }
        
        @keyframes edge-pop {
            0% { 
                transform: scale(1);
                filter: drop-shadow(0 0 0 rgba(168, 85, 247, 0));
            }
            50% { 
                transform: scale(1.05);
                filter: drop-shadow(0 0 10px rgba(168, 85, 247, 0.8));
            }
            100% { 
                transform: scale(1);
                filter: drop-shadow(0 0 5px rgba(168, 85, 247, 0.4));
            }
        }
        
        @keyframes matrix-scroll {
            from { 
                background-position: 0 0;
            }
            to { 
                background-position: 0 20px;
            }
        }
        
        @keyframes retro-grid-glow {
            from { 
                background-color: rgba(0, 255, 255, 0.05);
                filter: brightness(1);
            }
            to { 
                background-color: rgba(0, 255, 255, 0.15);
                filter: brightness(1.2);
            }
        }
        
        .monaco-editor .hidden-line {
            display: none;
        }
        .monaco-editor .current-cue-highlight {
            background-color: rgba(168, 85, 247, 0.15);
            width: 100%;
            display: block;
        }

        /* Ensure cue images always fill the subtitle area (unless overridden by a special effect) */
        #cue-image {
            width: 100%;
            height: auto;
            max-height: 100%; /* Never overflow vertically */
            object-fit: contain;
        }

        @keyframes emoji-fall-1 {
            0% { 
                transform: translateX(-50%) translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% { 
                transform: translateX(-50%) translateY(100px) rotate(360deg);
                opacity: 0;
            }
        }
        @keyframes emoji-fall-2 {
            0% { 
                transform: translateX(-50%) translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% { 
                transform: translateX(-50%) translateY(120px) rotate(-360deg);
                opacity: 0;
            }
        }

        /* Universal emoji rain effect - full background coverage */
        .fx-emoji-rain-universal {
            position: relative;
            animation: fade-in 0.3s ease-out;
        }
        
        /* Create full-screen emoji rain background */
        .emoji-rain-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }
        
        .emoji-rain-background::before,
        .emoji-rain-background::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 10% 20%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 30% 10%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 50% 30%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 70% 5%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 90% 25%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 15% 60%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 35% 70%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 55% 50%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 75% 80%, var(--emoji, '❤️') 0%, transparent 0%),
                radial-gradient(circle at 95% 65%, var(--emoji, '❤️') 0%, transparent 0%);
            background-size: 100px 100px;
            font-size: 24px;
            animation: emoji-rain-fall 3s linear infinite;
        }
        
        .emoji-rain-background::after {
            animation-delay: 1.5s;
            animation-duration: 4s;
            background-size: 80px 80px;
        }
        
        /* Alternative approach using pseudo-elements with actual emoji content */
        .emoji-rain-particles::before,
        .emoji-rain-particles::after {
            content: var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️') ' ' var(--emoji, '❤️');
            position: fixed;
            top: -50px;
            left: 0;
            width: 100vw;
            height: 50px;
            white-space: nowrap;
            font-size: 24px;
            line-height: 50px;
            pointer-events: none;
            z-index: 1;
            animation: emoji-rain-fall 4s linear infinite;
        }
        
        .emoji-rain-particles::after {
            animation-delay: 2s;
            animation-duration: 5s;
            font-size: 20px;
        }

        @keyframes emoji-rain-fall {
            0% { 
                transform: translateY(-100vh);
                opacity: 1;
            }
            100% { 
                transform: translateY(100vh);
                opacity: 0;
            }
        }

        /* Emoji storm effect within subtitle container */
        .emoji-storm-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 200px; /* Fixed height to cover subtitle area */
            min-height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: visible; /* Allow particles to be visible */
        }
        
        .emoji-storm-particle {
            position: absolute;
            font-size: 24px;
            pointer-events: none;
            animation: emoji-storm-fall ease-in-out infinite;
            opacity: 0.9;
        }
        
        .emoji-storm-particle:nth-child(2n) {
            animation-duration: 0.4s;
            animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            font-size: 20px;
        }
        
        .emoji-storm-particle:nth-child(3n) {
            animation-duration: 0.6s;
            animation-timing-function: cubic-bezier(0.55, 0.085, 0.68, 0.53);
            font-size: 28px;
        }
        
        .emoji-storm-particle:nth-child(4n) {
            animation-duration: 0.5s;
            animation-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            font-size: 22px;
        }
        
        .emoji-storm-particle:nth-child(5n) {
            animation-duration: 0.3s;
            animation-timing-function: cubic-bezier(0.55, 0.055, 0.675, 0.19);
            font-size: 26px;
        }
        
        .emoji-storm-particle:nth-child(6n) {
            animation-duration: 0.7s;
            animation-timing-function: ease-in-out;
            font-size: 18px;
        }
        
        .emoji-storm-particle:nth-child(7n) {
            animation-duration: 0.45s;
            animation-timing-function: cubic-bezier(0.68, -0.55, 0.265, 1.55);
            font-size: 30px;
        }
        
        .emoji-storm-particle:nth-child(8n) {
            animation-duration: 0.55s;
            animation-timing-function: cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-size: 16px;
        }
        
        .emoji-storm-particle:nth-child(9n) {
            animation-duration: 0.35s;
            animation-timing-function: cubic-bezier(0.39, 0.575, 0.565, 1);
            font-size: 24px;
        }
        
        .emoji-storm-particle:nth-child(10n) {
            animation-duration: 0.65s;
            animation-timing-function: cubic-bezier(0.645, 0.045, 0.355, 1);
            font-size: 32px;
        }

        @keyframes emoji-storm-fall {
            0% { 
                transform: translateY(-40px) translateX(0px) rotate(0deg) scale(1);
                opacity: 0;
            }
            15% {
                opacity: 1;
                transform: translateY(-20px) translateX(1px) rotate(45deg) scale(1);
            }
            30% {
                transform: translateY(40px) translateX(3px) rotate(90deg) scale(1.1);
                opacity: 0.9;
            }
            60% {
                transform: translateY(120px) translateX(-2px) rotate(180deg) scale(0.9);
                opacity: 0.7;
            }
            85% {
                transform: translateY(180px) translateX(4px) rotate(270deg) scale(1.05);
                opacity: 0.4;
            }
            100% { 
                transform: translateY(220px) translateX(0px) rotate(360deg) scale(0.7);
                opacity: 0;
            }
        }

        /* Ensure subtitle container can contain positioned storm effects */
        .subtitle-container {
            position: relative;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-4">
    
    <canvas id="backgroundCanvas" class="absolute top-0 left-0 w-full h-full z-0"></canvas>
    
    <div class="flex items-center justify-center w-full max-w-7xl h-full gap-4">
        <!-- Advanced Mode Editor Panel -->
        <div id="advancedModePanel" class="editor-wrapper h-[512px] bg-[#1e1e1e] rounded-2xl shadow-2xl flex-col transition-all duration-500 ease-in-out -translate-x-full w-0 shrink-0 hidden">
            <div class="flex-shrink-0 flex justify-between items-center p-3 border-b border-gray-700">
                   <h3 class="text-lg font-bold text-gray-300">Advanced VTT Editor</h3>
                   <div class="flex items-center gap-2">
                     <label for="editorImageUpload" title="Upload Image" class="p-2 rounded-full hover:bg-white/10 text-gray-400 cursor-pointer">
                         <i data-lucide="upload" class="w-[18px] h-[18px]"></i>
                     </label>
                     <input type="file" id="editorImageUpload" accept="image/*,image/gif" class="hidden" />
                     <button id="pasteImageBtn" title="Paste Image" class="p-2 rounded-full hover:bg-white/10 text-gray-400">
                         <i data-lucide="clipboard" class="w-[18px] h-[18px]"></i>
                     </button>
                     <button id="closeAdvancedMode" class="p-2 rounded-full hover:bg-white/10 text-gray-400">
                         <i data-lucide="x" class="w-[18px] h-[18px]"></i>
                     </button>
                   </div>
            </div>
            <div id="monacoEditorContainer" class="flex-grow w-full h-full"></div>
        </div>

        <div id="player-wrapper" class="player-wrapper w-full max-w-lg shrink-0">
            <div class="player-container flex flex-col w-full aspect-square bg-black/30 backdrop-blur-2xl p-6 sm:p-8 rounded-2xl shadow-2xl border border-white/10 overflow-hidden">
                <h1 id="editable-title" contenteditable="true" class="flex-shrink-0 text-xl sm:text-2xl font-bold text-center p-1">PodViewer</h1>
                
                <div class="relative flex-grow w-full bg-black/20 rounded-lg overflow-hidden my-4">
                    <div id="subtitle-container" class="absolute inset-0 flex items-center justify-center p-4 font-bold leading-tight">
                         <p id="subtitle-line" class="transition-opacity duration-300 flex flex-wrap gap-x-2 gap-y-4 items-center justify-center">Upload an audio and subtitle file to begin.</p>
                    </div>
                     <div id="image-container" class="absolute inset-0 p-4 flex items-center justify-center opacity-0 transition-opacity duration-300 pointer-events-none">
                         <img id="cue-image" src="" class="max-w-full max-h-full object-contain rounded-lg shadow-lg" />
                    </div>
                    <p id="brand-podviewer" class="absolute bottom-4 left-4 text-base font-bold bg-gradient-to-r from-purple-400 to-pink-500 bg-clip-text text-transparent p-1 transition-opacity duration-300">PodViewer</p>
                    <p id="brand-podcastby" contenteditable="true" class="absolute bottom-4 right-4 text-sm font-bold opacity-70 p-1 text-right transition-opacity duration-300">Podcast by: Your Name</p>
                    
                </div>

                <div id="controls-container" dir="ltr">
                    <div id="progressBarContainer" class="w-full h-2 bg-white/10 rounded-full cursor-pointer my-2">
                        <div id="progressBar" class="h-full bg-purple-500 rounded-full"></div>
                    </div>
                    <div class="flex-shrink-0 flex items-center justify-between gap-4 mt-2">
                        <div class="flex items-center gap-2 sm:gap-4">
                            <button id="resetBtn" class="group flex items-center p-3 bg-white/10 rounded-full text-white/80 hover:bg-white/20 hover:text-white transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                <i data-lucide="rotate-ccw" class="w-[18px] h-[18px]"></i>
                                <span class="button-label">Reset</span>
                            </button>
                             <button id="playPauseBtn" class="w-14 h-14 bg-purple-600 rounded-full flex items-center justify-center text-white shadow-lg disabled:bg-gray-500 disabled:cursor-not-allowed flex-shrink-0">
                                <i id="playIcon" data-lucide="play" class="w-6 h-6"></i>
                                <i id="pauseIcon" data-lucide="pause" class="w-6 h-6 hidden"></i>
                            </button>
                            <div id="timeDisplay" class="font-mono text-sm text-gray-300 w-28 text-center">00:00 / 00:00</div>
                        </div>
                        <div class="flex items-center gap-3">
                            <label for="audio-upload" class="group flex items-center p-3 rounded-full bg-white/10 border border-white/20 hover:bg-white/20 cursor-pointer transition-all duration-300">
                                <i data-lucide="music" class="w-[18px] h-[18px]"></i>
                                <span class="button-label">Audio</span>
                            </label>
                            <input type="file" id="audio-upload" accept=".mp3, .wav, .ogg" class="hidden">

                            <label for="subtitle-upload" class="group flex items-center p-3 rounded-full bg-white/10 border border-white/20 hover:bg-white/20 cursor-pointer transition-all duration-300">
                                <i data-lucide="captions" class="w-[18px] h-[18px]"></i>
                                <span class="button-label">Subtitles</span>
                            </label>
                            <input type="file" id="subtitle-upload" accept=".vtt" class="hidden">
                            
                            <button id="settingsBtn" class="group flex items-center p-3 bg-white/10 rounded-full text-white/80 hover:bg-white/20 hover:text-white transition-all duration-300">
                                 <i data-lucide="settings" class="w-[18px] h-[18px]"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <audio id="audioPlayer" class="hidden"></audio>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 hidden">
        <div dir="ltr" class="bg-gray-800/80 backdrop-blur-lg p-6 rounded-2xl w-full max-w-sm border border-white/10 shadow-2xl">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold">Live Settings</h2>
                <button id="closeSettingsBtn" class="p-2 rounded-full hover:bg-white/10">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <div class="space-y-6">
              <details open class="mb-2">
                <summary class="font-semibold cursor-pointer py-2">Modes</summary>
                <div class="pl-4 space-y-4">
                   <div class="flex justify-between items-center">
                     <label for="advancedModeToggle" class="block text-sm font-medium">Advanced Mode</label>
                     <button id="advancedModeToggle" type="button" class="bg-gray-600 relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-800" role="switch" aria-checked="false">
                         <span aria-hidden="true" class="translate-x-0 pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"></span>
                     </button>
                 </div>
                 <div class="flex justify-between items-center">
                     <label for="focusModeToggle" class="block text-sm font-medium">Editor Focus Mode</label>
                     <button id="focusModeToggle" type="button" class="bg-gray-600 relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-800" role="switch" aria-checked="false">
                         <span aria-hidden="true" class="translate-x-0 pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"></span>
                     </button>
                 </div>
                  <div class="flex justify-between items-center">
                    <label for="demoModeToggle" class="block text-sm font-medium">Demo Mode (Show All Effects)</label>
                    <button id="demoModeToggle" type="button" class="bg-gray-600 relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-800" role="switch" aria-checked="false">
                      <span class="sr-only">Use setting</span>
                      <span aria-hidden="true" class="translate-x-0 pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"></span>
                    </button>
                  </div>
                </div>
              </details>
              <details class="mb-2">
                <summary class="font-semibold cursor-pointer py-2">Effects</summary>
                <div class="pl-4 space-y-4">
                   <div class="flex justify-between items-center">
                     <label for="kineticToggle" class="block text-sm font-medium">Kinetic Effects</label>
                     <button id="kineticToggle" type="button" class="bg-gray-600 relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-800" role="switch" aria-checked="true">
                         <span class="sr-only">Use setting</span>
                         <span aria-hidden="true" class="translate-x-5 pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"></span>
                     </button>
                 </div>
                   <div class="flex justify-between items-center">
                     <label for="imageToggle" class="block text-sm font-medium">Show Images</label>
                     <button id="imageToggle" type="button" class="bg-gray-600 relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-800" role="switch" aria-checked="true">
                         <span class="sr-only">Use setting</span>
                         <span aria-hidden="true" class="translate-x-5 pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"></span>
                     </button>
                 </div>
                 <div class="flex justify-between items-center">
                     <label for="rtlToggle" class="block text-sm font-medium">RTL Mode (for Arabic)</label>
                     <button id="rtlToggle" type="button" class="bg-gray-600 relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 focus:ring-offset-gray-800" role="switch" aria-checked="false">
                         <span class="sr-only">Use setting</span>
                         <span aria-hidden="true" class="translate-x-0 pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"></span>
                     </button>
                 </div>
                </div>
              </details>
              <details class="mb-2">
                <summary class="font-semibold cursor-pointer py-2">Appearance</summary>
                <div class="pl-4 space-y-4">
                 <div>
                     <label for="highlightOffset" class="block text-sm font-medium mb-2">Highlight Timing Offset (<span id="highlightOffsetText">0.00s</span>)</label>
                     <input id="highlightOffset" type="range" min="-0.5" max="0.5" step="0.05" value="0" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                 </div>
                 <div>
                     <label for="highlightPacing" class="block text-sm font-medium mb-2">Highlight Pacing (<span id="highlightPacingText">1.00x</span>)</label>
                     <input id="highlightPacing" type="range" min="0.5" max="2.0" step="0.05" value="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                 </div>
                 <div>
                     <label for="fontSelect" class="block text-sm font-medium mb-2">Font Style</label>
                     <select id="fontSelect" class="w-full bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-purple-500 focus:border-purple-500 block p-2.5">
                         <option>Inter</option>
                         <option>Poppins</option>
                         <option value="'Roboto Slab', serif">Roboto Slab</option>
                         <option value="'Playfair Display', serif">Playfair Display</option>
                         <option value="'IBM Plex Sans Arabic', sans-serif">IBM Plex Sans Arabic</option>
                     </select>
                 </div>
                 <div>
                     <label for="fontSize" class="block text-sm font-medium mb-2">Font Size (<span id="fontSizeText">30px</span>)</label>
                     <input id="fontSize" type="range" min="20" max="60" step="1" value="30" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                 </div>
                 <div>
                     <label for="bgBlur" class="block text-sm font-medium mb-2">Background Blur (<span id="bgBlurText">80px</span>)</label>
                     <input id="bgBlur" type="range" min="20" max="150" step="1" value="80" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                 </div>
                </div>
              </details>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.41.0/min/vs/loader.js"></script>
    <script>
    window.onload = function() {
        // --- SETTINGS STATE ---
        let settings = {
            advancedModeEnabled: false,
            focusModeEnabled: false,
            kineticEnabled: true,
            imagesEnabled: true,
            rtlEnabled: false,
            demoModeEnabled: false,
            highlightOffset: 0,
            highlightPacing: 1.0,
            fontFamily: 'Inter',
            fontSize: 30,
            backgroundBlur: 80,
        };

        // --- MOOD PRESETS ---
        const moodPresets = {
            default: { palette: ['#a855f7', '#ec4899', '#22c55e', '#f59e0b', '#3b82f6'], frequency: 0.95 },
            angry: { palette: ['#991b1b', '#b91c1c', '#dc2626', '#ef4444', '#f87171'], frequency: 0.80 },
            calm: { palette: ['#1e3a8a', '#1e40af', '#1d4ed8', '#2563eb', '#3b82f6'], frequency: 0.98 },
            happy: { palette: ['#f59e0b', '#facc15', '#fde047', '#fef08a', '#fffbeb'], frequency: 0.90 },
            sad: { palette: ['#4b5563', '#6b7280', '#9ca3af', '#d1d5db', '#e5e7eb'], frequency: 0.99 },
        };
        let currentMood = moodPresets.default;
        let rawVTTContent = 'WEBVTT\n\n00:00.378 --> 00:01.198\n<fx:title1>The Setup</fx:title1>\n\n00:01.198 --> 00:2.558\nThis setup, the setting scene.\n\n00:02.558 --> 00:4.658\nPicture this, June 2025.\n\n00:04.658 --> 00:6.728\nOpenAI drops a <fx:burst>bombshell</fx:burst>.\n\n00:06.728 --> 00:13.168\nO3 Pro, their shiny new AI, and an 80% price slash for the standard O3 model.\n\n00:13.168 --> 00:15.938\nThey\'re about to <fx:pulse>dominate</fx:pulse> the AI game forever.\n\n00:15.938 --> 00:17.978\nOr so they thought.\n\n00:17.978 --> 00:19.688\n<fx:title1>The Big Promise</fx:title1>\n\n00:19.688 --> 00:25.048\nO3 Pro, smarter reasoning, slick tools, and O3 now <fx:glow>dirt cheap</fx:glow>.\n\n00:25.048 --> 00:28.988\nO3 Pro promises <fx:laser>PhD level</fx:laser> problem solving,\n\n00:28.988 --> 00:33.438\nwhile O3\'s price drops from $100 to $2 per million tokens.\n\n00:33.438 --> 00:36.468\nAccessible, powerful, <fx:wave>revolutionary</fx:wave>.\n\n00:36.468 --> 00:38.258\nX users lose their minds.\n\n00:38.258 --> 00:40.458\n<img:https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExazJ0NjN1a3p5ZDI4N3l0aWI1MXR3Z2x2a2QwZHAwN3F6Z2llaGZ0MiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/6pJNYBYSMFod2/giphy.gif,fx:slow-zoom-in>\n\n00:40.458 --> 00:41.978\n<fx:title1>The Harsh Reality</fx:title1>\n\n00:41.978 --> 00:43.708\n<mood:angry>Launch day hits.\n\n00:43.708 --> 00:45.898\nUsers on X <fx:shake>cry foul</fx:shake>.\n\n00:45.898 --> 00:48.718\nIs the cheaper O3 just a <fx:rgb-glitch>dumber version</fx:rgb-glitch>?\n\n00:48.718 --> 00:53.488\nGreat. We get a budget AI that\'s fast but <fx:shake>flops</fx:shake> on tough tasks.\n\n00:53.488 --> 00:55.338\nClassic OpenAI move.\n\n00:55.338 --> 00:57.288\n<img:https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExZmJzbXhqc3VrNzIyMXdvdTdrcnp5dGNjM2MycG8xOHd6Y2xkbG5zdCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/NTur7XlVDUdqM/giphy.gif,fx:slow-zoom-in>\n\n00:57.288 --> 00:58.588\n<fx:title1>The Plot Twist</fx:title1>\n\n00:58.588 --> 01:00.418\n<mood:default>But wait, there\'s more.\n\n01:00.418 --> 01:03.958\nTech sleuths on X dig into the price cut.\n\n01:03.958 --> 01:09.118\nThey suspect OpenAI is <fx:laser>slashing compute</fx:laser> to save cash, not help users.\n\n01:09.118 --> 01:15.548\nAnd O3 Pro costs $80 per million tokens, <fx:burst>40 times pricier</fx:burst>.\n\n01:15.548 --> 01:17.448\n<img:https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3Zkd3l1bjMzN2h3MWdudjRmZHFyZXV2c3p4NG41cjllcXQxbnE5cCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/5aLrlDiJPMPFS/giphy.gif,fx:slow-zoom-in>\n\n01:17.448 --> 01:19.498\n<fx:title1>The Community Strikes Back</fx:title1>\n\n01:19.498 --> 01:21.848\n<mood:happy>X <fx:confetti>explodes with shade</fx:confetti>.\n\n01:21.848 --> 01:25.598\n#O3pricecut <fx:wave>trends worldwide</fx:wave>.\n\n01:25.598 --> 01:28.598\nUsers demand proof O3 isn\'t nerfed.\n\n01:28.598 --> 01:31.798\nSam Altman stays <fx:fade-in>silent</fx:fade-in>, tweeting memes instead.\n\n01:31.798 --> 01:33.498\n<img:https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExMG90NnR4ZngweHkwbXI2dmV5c2N6eHFzM2luYm80aXlybTZta2RteiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/RILsqUte1MME7TzQJ9/giphy.gif,fx:slow-zoom-in>\n\n01:33.498 --> 01:35.398\n<fx:title1>The Deeper Conspiracy</fx:title1>\n\n01:35.398 --> 01:37.318\n<mood:sad><fx:typing>Here\'s the real kicker.</fx:typing>\n\n01:37.318 --> 01:39.878\n<fx:reveal-circle>Leaked benchmarks</fx:reveal-circle> surface on X.\n\n01:39.878 --> 01:41.528\nExplosive reveal.\n\n01:41.528 --> 01:46.068\nO3 Pro\'s hyped reasoning, <fx:rgb-glitch>riddled with errors</fx:rgb-glitch> for some tasks.\n\n01:46.068 --> 01:51.588\nPhilosophical, is OpenAI just flooding the market to <fx:shake>crush Google and Anthropic?</fx:shake>\n\n01:51.588 --> 01:53.308\n<fx:title1>The Hero\'s Journey</fx:title1>\n\n01:53.308 --> 01:55.518\n<mood:happy>But the X community <fx:pulse>fights back</fx:pulse>.\n\n01:55.518 --> 01:57.418\n<img:https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExcTRhM3V1MmVqcGU1c2d0Y2dwOHdqcGVnYTM3OXV3cDk2OG9yaDZxOCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/S6qkS0ETvel6EZat45/giphy.gif,fx:slow-zoom-in>\n\n01:57.418 --> 02:01.378\nDevelopers test O3 Pro, share workarounds for its quirks.\n\n02:01.378 --> 02:06.018\nTriumphant, <fx:glow>real AI progress</fx:glow> driven by users, not hype.\n\n02:06.018 --> 02:08.688\nNo corporate gatekeeping required.\n\n02:08.688 --> 02:10.018\n<fx:title1>The Resolution</fx:title1>\n\n02:10.018 --> 02:11.398\n<mood:default>A week later.\n\n02:11.398 --> 02:15.708\nOpenAI promises clarifications on O3\'s performance.\n\n02:15.708 --> 02:18.068\nWe learned to question the hype.\n\n02:18.068 --> 02:20.918\nThe truth always surfaces on X.\n\n02:20.918 --> 02:22.568\n<fx:title1>The Moral of the Story</fx:title1>\n\n02:22.568 --> 02:27.738\nSometimes the biggest promises hide the <fx:shake>shadiest moves</fx:shake>.\n\n02:27.738 --> 02:30.678\nDon\'t trust the AI hype machine.\n\n02:30.678 --> 02:31.958\nThanks for watching.\n\n02:31.958 --> 02:33.728\nYou stayed for the whole drama.\n\n02:33.728 --> 02:36.568\nDrop your OpenAI horror stories below.\n\n02:36.568 --> 02:38.838\nSubscribe for more tech tea.';
        let pastedImages = {};
        let lastRevealedLine = -1;
        let editorDecorations = [];
        let activeCueForFocusMode = null;
        let previousActiveCueId = null; // Track when active cue changes
        let isUserTyping = false; // Track if user is currently editing
        let typingTimeout = null; // Debounce typing updates

        // --- DEMO MODE STATE ---
        let demoEffects = [
            { name: 'Title Effects', effects: ['fx:title1', 'fx:title2', 'fx:title3'] },
            { name: 'Basic Animations', effects: ['fx:shake', 'fx:pulse', 'fx:wave', 'fx:zoom-in', 'fx:slide-up', 'fx:fade-in'] },
            { name: 'Advanced Effects', effects: ['fx:burst', 'fx:rgb-glitch', 'fx:laser', 'fx:reveal-circle', 'fx:confetti'] },
            { name: 'Text Effects', effects: ['fx:wave-mask', 'fx:glow', 'fx:glitch'] },
            { name: 'Emoji Rain', effects: ['fx:emoji-rain:🔥', 'fx:emoji-rain:😂', 'fx:emoji-rain:🎉', 'fx:emoji-rain:⚡'] },
            { name: 'Background Scenes', effects: ['bg:matrix', 'bg:retro-grid'] },
            { name: 'Color Effects', effects: ['c:#ff6b6b', 'c:#4ecdc4', 'c:#45b7d1', 'c:#f9ca24', 'c:#a855f7'] }
        ];
        let demoCurrentCategory = 0;
        let demoCurrentEffect = 0;
        let demoInterval = null;
        let demoStartTime = 0;

        // --- DOM ELEMENT REFERENCES ---
        const playerWrapper = document.getElementById('player-wrapper');
        const audioPlayer = document.getElementById('audioPlayer');
        const audioUpload = document.getElementById('audio-upload');
        const subtitleUpload = document.getElementById('subtitle-upload');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        // Use let so we can refresh references after Lucide replaces the <i> tags with <svg>
        let playIcon = document.getElementById('playIcon');
        let pauseIcon = document.getElementById('pauseIcon');
        
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        const subtitleContainer = document.getElementById('subtitle-container');
        const subtitleLine = document.getElementById('subtitle-line');
        const imageContainer = document.getElementById('image-container');
        const cueImage = document.getElementById('cue-image');
        const timeDisplay = document.getElementById('timeDisplay');
        const progressBar = document.getElementById('progressBar');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const controlsContainer = document.getElementById('controls-container');
        const brandPodviewer = document.getElementById('brand-podviewer');
        const brandPodcastBy = document.getElementById('brand-podcastby');
        const advancedModePanel = document.getElementById('advancedModePanel');
        const monacoEditorContainer = document.getElementById('monacoEditorContainer');
        const closeAdvancedModeBtn = document.getElementById('closeAdvancedMode');
        const editorImageUploadInput = document.getElementById('editorImageUpload');
        const pasteImageBtn = document.getElementById('pasteImageBtn'); // New: Paste Image Button
        
        // Settings Modal Elements
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        const advancedModeToggle = document.getElementById('advancedModeToggle');
        const focusModeToggle = document.getElementById('focusModeToggle');
        const kineticToggle = document.getElementById('kineticToggle');
        const imageToggle = document.getElementById('imageToggle');
        const rtlToggle = document.getElementById('rtlToggle');
        const demoModeToggle = document.getElementById('demoModeToggle');
        const highlightOffsetSlider = document.getElementById('highlightOffset');
        const highlightOffsetText = document.getElementById('highlightOffsetText');
        const highlightPacingSlider = document.getElementById('highlightPacing');
        const highlightPacingText = document.getElementById('highlightPacingText');
        const fontSelect = document.getElementById('fontSelect');
        const fontSizeSlider = document.getElementById('fontSize');
        const fontSizeText = document.getElementById('fontSizeText');
        const bgBlurSlider = document.getElementById('bgBlur');
        const bgBlurText = document.getElementById('bgBlurText');

        // Audio & Subtitle State
        let audioContext;
        let analyser;
        let source;
        let subtitles = [];
        let isReadyToPlay = false;
        let monacoEditor;

        const backgroundCtx = backgroundCanvas.getContext('2d');
        
        // --- New helper functions for VTT serialization ---
        function formatTime(seconds) {
            // Helper function to format seconds into HH:MM:SS.mmm (or MM:SS.mmm if hours are zero)
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;
            const ms = Math.floor((remainingSeconds - Math.floor(remainingSeconds)) * 1000);
            const s = Math.floor(remainingSeconds);

            let parts = [];
            if (hours > 0) {
                parts.push(hours.toString().padStart(2, '0'));
            }
            parts.push(minutes.toString().padStart(2, '0'));
            parts.push(s.toString().padStart(2, '0'));

            return `${parts.join(':')}.${ms.toString().padStart(3, '0')}`;
        }

        function serializeVTT(cues) {
            // Serializes the internal `subtitles` array back into a VTT string.
            // This is crucial for ensuring that edits made in the editor (especially in focus mode)
            // are correctly persisted back into the `rawVTTContent`.
            let vtt = 'WEBVTT\n\n';
            cues.forEach(cue => {
                // Add timestamps
                vtt += `${formatTime(cue.start)} --> ${formatTime(cue.end)}\n`;
                
                // Check if originalText already contains mood tags to prevent duplication
                const moodRegex = /<mood:[^>]+>/;
                const hasMoodTag = moodRegex.test(cue.originalText);
                
                let cueTextParts = [];
                
                // Only add mood tag if it doesn't already exist in originalText and mood data exists
                if (!hasMoodTag && cue.mood && cue.mood.name) {
                    let moodTag = `<mood:${cue.mood.name}`;
                    if (cue.mood.frequency !== null && cue.mood.frequency !== undefined) {
                        moodTag += `,${cue.mood.frequency}`;
                    }
                    moodTag += `>`;
                    cueTextParts.push(moodTag);
                }

                // Append the originalText from the cue, as this is the canonical source
                // which has been updated by the editor in focus mode.
                // We're deliberately using cue.originalText here because it holds the raw VTT segment
                // that might contain custom tags, which should be preserved.
                cueTextParts.push(cue.originalText);
                
                vtt += cueTextParts.join(' ').trim() + '\n\n'; // Join parts with space and add double newline for next cue
            });
            return vtt.trim(); // Trim any trailing newlines at the end of the VTT
        }

        // --- 1. FILE UPLOAD AND PREPARATION ---
        audioUpload.addEventListener('change', (event) => {
            console.log("Audio file selected.");
            const file = event.target.files[0];
            if (file) {
                const objectUrl = URL.createObjectURL(file);
                audioPlayer.src = objectUrl;
                subtitleLine.textContent = 'Audio loaded. Please upload subtitles.';
                checkIfReady();
            }
        });

        subtitleUpload.addEventListener('change', (event) => {
            console.log("Subtitle file selected.");
            const file = event.target.files[0];
            if (file) {
                // Stop current playback and reset time so the new subtitles start fresh
                audioPlayer.pause();
                audioPlayer.currentTime = 0;

                // Clear previous subtitles data to avoid any persistence issues
                subtitles = [];
                activeCueForFocusMode = null;
                previousActiveCueId = null;
                lastRevealedLine = -1;

                // Clear on-screen subtitle / image immediately
                subtitleLine.textContent = '';
                imageContainer.style.opacity = '0';
                subtitleContainer.style.opacity = '1';
                subtitleContainer.classList.remove('bg-matrix', 'bg-retro-grid');

                const reader = new FileReader();
                reader.onload = (e) => {
                    rawVTTContent = e.target.result;
                    if (monacoEditor) {
                        monacoEditor.setValue(rawVTTContent);
                    }

                    subtitles = parseVTTWithEffects(rawVTTContent);

                    // Reset the on–screen cue text immediately
                    subtitleLine.textContent = subtitles.length > 0 ? 'Subtitles loaded. Ready to play!' : 'Could not parse VTT file. Please check format.';

                    // Make sure the progress bar goes back to zero
                    progressBar.style.width = '0%';

                    // Refresh the on-screen subtitle area so no remnants from previous file remain
                    updateSubtitles();

                    checkIfReady();
                };
                reader.readAsText(file);
            }
        });

        function checkIfReady() {
            if (audioPlayer.src && subtitles.length > 0) {
                playPauseBtn.disabled = false;
                resetBtn.disabled = false;
                isReadyToPlay = true;
                subtitleLine.textContent = 'Ready to play!';
                
                // Stop demo mode when real content is loaded
                if (settings.demoModeEnabled) {
                    settings.demoModeEnabled = false;
                    updateToggleUI(demoModeToggle, false);
                    stopDemoMode();
                }
            }
                
                // Parse the default VTT content and log the results for debugging
                console.log("=== VTT PARSING TEST ===");
                const testSubtitles = parseVTTWithEffects(rawVTTContent);
            console.log("Raw VTT Content:", rawVTTContent);
                console.log("Parsed subtitles:", testSubtitles);
                testSubtitles.forEach((cue, index) => {
                    console.log(`Cue ${index + 1}:`, cue.originalText);
                    console.log("Words:", cue.words);
                console.log("Start:", cue.start, "End:", cue.end);
                });
                console.log("Kinetic enabled:", settings.kineticEnabled);
                console.log("=== END TEST ===");
        }
        
        // --- 2. SUBTITLE PARSING WITH EFFECTS ---
        function parseVTTWithEffects(vttContent) {
            const lines = vttContent.replace(/\r\n/g, '\n').split('\n');
            const cues = [];
            let i = 0;
            const timeToSeconds = (timeStr) => {
                if(!timeStr) return 0;
                const parts = timeStr.split(':');
                let seconds = 0;
                if (parts.length === 3) { seconds += parseFloat(parts[0]) * 3600; seconds += parseFloat(parts[1]) * 60; seconds += parseFloat(parts[2]); } 
                else if (parts.length === 2) { seconds += parseFloat(parts[0]) * 60; seconds += parseFloat(parts[1]); }
                return seconds;
            };

            while(i < lines.length) {
                if (lines[i].trim() === '' || lines[i].includes('WEBVTT')) { i++; continue; }
                const timeMatch = lines[i].match(/(\d{1,2}:)?\d{1,2}:\d{1,2}\.\d{3} --> (\d{1,2}:)?\d{1,2}:\d{1,2}\.\d{3}/);
                if (timeMatch) {
                    const cueLineNumber = i + 1; // Store original line number for editor highlighting
                    const [startTime, endTime] = lines[i].split(' --> ');
                    const start = timeToSeconds(startTime);
                    const end = timeToSeconds(endTime);
                    i++;
                    let text = '';
                    while(i < lines.length && lines[i].trim() !== '' && !lines[i].includes('-->')) {
                        text += (text ? ' ' : '') + lines[i].trim();
                        i++;
                    }
                    
                    const moodRegex = /<mood:([^>]+)>/;
                    const moodMatch = text.match(moodRegex);
                    let mood = null;
                    let processedText = text; // Text after removing mood tag for further parsing

                    if(moodMatch) {
                        processedText = text.replace(moodRegex, '').trim();
                        const [moodName, frequency] = moodMatch[1].split(',');
                        mood = { 
                            name: moodName.trim(), 
                            frequency: frequency ? parseFloat(frequency) : null 
                        };
                    }
                    
                    // Handle background scene tags
                    const bgRegex = /<bg:([^>]+)>/;
                    const bgMatch = processedText.match(bgRegex);
                    let backgroundScene = null;
                    
                    if(bgMatch) {
                        backgroundScene = `bg-${bgMatch[1].trim()}`;
                        processedText = processedText.replace(bgRegex, '').trim();
                    }
                    
                    const finalWords = [];
                    // Updated regex to better handle emoji characters and special closing tags
                    const regex = /<([a-zA-Z0-9\-]+):([^>]+)>(.*?)<\/\1(?::[^>]*)?>|<(img):([^>]+)>/g;
                    let lastIndex = 0;
                    let wordMatch;
                    
                    console.log(`Parsing cue text: "${processedText}"`);
                    
                    // Improved regex that handles emoji characters better
                    const effectsRegex = /<([a-zA-Z0-9\-]+):([^>]*?)>(.*?)<\/\1(?::[^>]*)?>/g;
                    
                    while ((wordMatch = effectsRegex.exec(processedText)) !== null) {
                        console.log("Found match:", wordMatch);
                        // Add any plain text before the current tag
                        if (wordMatch.index > lastIndex) {
                            const plainText = processedText.substring(lastIndex, wordMatch.index);
                            console.log("Adding plain text:", plainText);
                            plainText.trim().split(' ').filter(w => w).forEach(word => {
                                finalWords.push({ type: 'text', text: word, effects: {} });
                            });
                        }
                        
                        const [, tagType, tagValue, tagContent] = wordMatch;
                        console.log(`Matched tag: ${tagType}:${tagValue} with content: "${tagContent}"`);
                        const effects = {};
                        
                        if (tagType === 'c') {
                            effects.color = tagValue;
                        } else if (tagType === 'fx') {
                            effects.animation = tagValue;
                            console.log(`Parsed fx effect: ${tagValue} for content: "${tagContent}"`);
                        }
                        
                        if (tagContent.trim()) {
                            tagContent.trim().split(' ').filter(w => w).forEach(word => {
                                console.log(`Adding word with effects:`, { text: word, effects: effects });
                                finalWords.push({ type: 'text', text: word, effects: effects });
                            });
                        }
                        
                        lastIndex = effectsRegex.lastIndex;
                    }
                    
                    // Handle standalone image tags
                    const imageRegex = /<(img):([^>]+)>/g;
                    let imageMatch;
                    while ((imageMatch = imageRegex.exec(processedText)) !== null) {
                        if (imageMatch.index >= lastIndex) {
                            const parts = imageMatch[2].split(',');
                            const src = parts[0].trim();
                            const effects = {};
                            if(parts[1]) {
                                const fxPart = parts[1].trim();
                                if(fxPart.startsWith('fx:')) {
                                    effects.animation = fxPart.substring(3);
                                }
                            }
                            finalWords.push({ type: 'image', src: src, effects: effects });
                        }
                    }

                    // Add any remaining plain text after the last tag
                    if (lastIndex < processedText.length) {
                        const plainText = processedText.substring(lastIndex);
                        console.log("Adding remaining plain text:", plainText);
                        plainText.trim().split(' ').filter(w => w).forEach(word => {
                            finalWords.push({ type: 'text', text: word, effects: {} });
                        });
                    }

                    console.log("Final words array:", finalWords);

                    cues.push({ start, end, words: finalWords, mood: mood, lineNumber: cueLineNumber, originalText: text, backgroundScene });
                } else {
                    i++;
                }
            }
            return cues;
        }

        // --- DEMO MODE FUNCTIONS ---
        function startDemoMode() {
            console.log("Starting demo mode");
            demoCurrentCategory = 0;
            demoCurrentEffect = 0;
            demoStartTime = Date.now();
            
            // Create demo subtitle content
            createDemoSubtitle();
            
            // Start cycling through effects
            demoInterval = setInterval(cycleDemoEffect, 1500); // Change effect every 1.5 seconds
            
            // Show info in subtitle line
            subtitleLine.innerHTML = `<div style="text-align: center; margin-bottom: 10px;"><strong>Demo Mode Active</strong><br><span style="opacity: 0.7; font-size: 0.8em;">Cycling through all available effects</span></div>`;
        }
        
        function stopDemoMode() {
            console.log("Stopping demo mode");
            if (demoInterval) {
                clearInterval(demoInterval);
                demoInterval = null;
            }
            
            // Clear demo subtitle
            subtitleLine.innerHTML = 'Upload an audio and subtitle file to begin.';
            imageContainer.style.opacity = '0';
            subtitleContainer.classList.remove('bg-matrix', 'bg-retro-grid');
        }
        
        function cycleDemoEffect() {
            const currentCategory = demoEffects[demoCurrentCategory];
            const currentEffect = currentCategory.effects[demoCurrentEffect];
            
            console.log(`Demo: ${currentCategory.name} - ${currentEffect}`);
            
            // Create demo content based on effect type
            let demoContent = '';
            let hasBackground = false;
            
            if (currentEffect.startsWith('bg:')) {
                hasBackground = true;
                subtitleContainer.classList.remove('bg-matrix', 'bg-retro-grid');
                subtitleContainer.classList.add(currentEffect.replace(':', '-'));
                demoContent = `<div class="text-center"><strong>${currentCategory.name}</strong><br><span class="text-lg">Background: ${currentEffect}</span></div>`;
            } else if (currentEffect.startsWith('c:')) {
                const color = currentEffect.split(':')[1];
                demoContent = `<div class="text-center"><strong>${currentCategory.name}</strong><br><span class="text-xl is-highlighted" style="color: ${color};">Colored Text</span></div>`;
            } else if (currentEffect.startsWith('fx:')) {
                const effectName = currentEffect.split(':')[1];
                let effectClass = `fx-${effectName}`;
                
                // Handle special emoji rain effects
                if (effectName.startsWith('emoji-rain')) {
                    const parts = effectName.split(':');
                    if (parts.length > 1) {
                        const emoji = parts[1];
                        effectClass = `fx-emoji-rain`;
                        // Create custom style for this emoji
                        const styleId = `demo-emoji-${Date.now()}`;
                        const style = document.createElement('style');
                        style.id = styleId;
                        style.textContent = `
                            .${styleId}::before {
                                content: '${emoji}';
                                position: absolute;
                                top: -50px;
                                left: 50%;
                                width: 2px;
                                height: 2px;
                                color: transparent;
                                font-size: 20px;
                                animation: emoji-storm-1 3s linear infinite;
                                pointer-events: none;
                                z-index: 10;
                                box-shadow: 
                                    -100px 0 0 0 currentColor, -80px 0 0 0 currentColor, -60px 0 0 0 currentColor, -40px 0 0 0 currentColor, -20px 0 0 0 currentColor,
                                    0px 0 0 0 currentColor, 20px 0 0 0 currentColor, 40px 0 0 0 currentColor, 60px 0 0 0 currentColor, 80px 0 0 0 currentColor, 100px 0 0 0 currentColor,
                                    -90px 20px 0 0 currentColor, -70px 20px 0 0 currentColor, -50px 20px 0 0 currentColor, -30px 20px 0 0 currentColor, -10px 20px 0 0 currentColor,
                                    10px 20px 0 0 currentColor, 30px 20px 0 0 currentColor, 50px 20px 0 0 currentColor, 70px 20px 0 0 currentColor, 90px 20px 0 0 currentColor,
                                    -110px 40px 0 0 currentColor, -85px 40px 0 0 currentColor, -65px 40px 0 0 currentColor, -45px 40px 0 0 currentColor, -25px 40px 0 0 currentColor,
                                    -5px 40px 0 0 currentColor, 15px 40px 0 0 currentColor, 35px 40px 0 0 currentColor, 55px 40px 0 0 currentColor, 75px 40px 0 0 currentColor, 95px 40px 0 0 currentColor;
                            }
                            .${styleId}::after {
                                content: '${emoji}';
                                position: absolute;
                                top: -70px;
                                left: 50%;
                                width: 2px;
                                height: 2px;
                                color: transparent;
                                font-size: 18px;
                                animation: emoji-storm-2 3.5s linear infinite 1s;
                                pointer-events: none;
                                z-index: 9;
                                box-shadow: 
                                    -95px 10px 0 0 currentColor, -75px 10px 0 0 currentColor, -55px 10px 0 0 currentColor, -35px 10px 0 0 currentColor, -15px 10px 0 0 currentColor,
                                    5px 10px 0 0 currentColor, 25px 10px 0 0 currentColor, 45px 10px 0 0 currentColor, 65px 10px 0 0 currentColor, 85px 10px 0 0 currentColor,
                                    -105px 30px 0 0 currentColor, -80px 30px 0 0 currentColor, -60px 30px 0 0 currentColor, -40px 30px 0 0 currentColor, -20px 30px 0 0 currentColor,
                                    0px 30px 0 0 currentColor, 20px 30px 0 0 currentColor, 40px 30px 0 0 currentColor, 60px 30px 0 0 currentColor, 80px 30px 0 0 currentColor, 100px 30px 0 0 currentColor,
                                    -115px 50px 0 0 currentColor, -90px 50px 0 0 currentColor, -70px 50px 0 0 currentColor, -50px 50px 0 0 currentColor, -30px 50px 0 0 currentColor,
                                    -10px 50px 0 0 currentColor, 10px 50px 0 0 currentColor, 30px 50px 0 0 currentColor, 50px 50px 0 0 currentColor, 70px 50px 0 0 currentColor, 90px 50px 0 0 currentColor;
                            }
                        `;
                        document.head.appendChild(style);
                        effectClass = `fx-emoji-rain ${styleId}`;
                        // Clean up after effect
                        setTimeout(() => {
                            if (style.parentNode) {
                                style.parentNode.removeChild(style);
                            }
                        }, 4000);
                    }
                }
                
                demoContent = `<div class="text-center"><strong>${currentCategory.name}</strong><br><span class="text-2xl is-highlighted ${effectClass}">Effect Demo</span></div>`;
            }
            
            // Clear background if not a background effect
            if (!hasBackground) {
                subtitleContainer.classList.remove('bg-matrix', 'bg-retro-grid');
            }
            
            // Update subtitle content
            subtitleLine.innerHTML = demoContent;
            
            // Move to next effect
            demoCurrentEffect++;
            if (demoCurrentEffect >= currentCategory.effects.length) {
                demoCurrentEffect = 0;
                demoCurrentCategory++;
                if (demoCurrentCategory >= demoEffects.length) {
                    demoCurrentCategory = 0;
                }
            }
        }
        
        function createDemoSubtitle() {
            // Ensure we're showing subtitles, not images
            imageContainer.style.opacity = '0';
            subtitleContainer.style.opacity = '1';
            
            // Enable kinetic effects for demo
            const wasKineticEnabled = settings.kineticEnabled;
            settings.kineticEnabled = true;
            
            // Start first effect immediately
            cycleDemoEffect();
        }

        // --- 3. AUDIO VISUALIZATION (WEB AUDIO API) ---
        function setupAudioContext() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 512;
            analyser.smoothingTimeConstant = 0.85;
            source = audioContext.createMediaElementSource(audioPlayer);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }

        let particles = [];

        function drawDynamicBackground() {
            if (!analyser) return; 
            const { width, height } = backgroundCanvas;
            backgroundCtx.clearRect(0, 0, width, height);
            backgroundCtx.filter = `blur(${settings.backgroundBlur}px)`;
            
            const bufferLength = analyser.frequencyBinCount;
            const frequencyData = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(frequencyData);

            const bass = frequencyData.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
            const mids = frequencyData.slice(10, 40).reduce((a, b) => a + b, 0) / 30;
            
            if (particles.length < 15 && Math.random() > currentMood.frequency) {
                   particles.push({
                     x: Math.random() * width,
                     y: Math.random() * height,
                     vx: (Math.random() - 0.5) * 1,
                     vy: (Math.random() - 0.5) * 1,
                     radius: 50 + Math.random() * 100,
                     color: currentMood.palette[Math.floor(Math.random() * currentMood.palette.length)],
                   });
            }
            
            particles.forEach((p, i) => {
                p.x += p.vx + (Math.random() - 0.5) * (mids/255);
                p.y += p.vy + (Math.random() - 0.5) * (mids/255);
                p.radius = 80 + (bass * 1.5) + Math.sin(p.x * 0.01) * 20;

                if (p.x - p.radius > width || p.x + p.radius < 0 || p.y - p.radius > height || p.y + p.radius < 0) {
                    particles.splice(i, 1);
                }
                backgroundCtx.beginPath();
                backgroundCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                backgroundCtx.fillStyle = p.color;
                backgroundCtx.globalAlpha = 0.6;
                backgroundCtx.fill();
            });
            backgroundCtx.filter = 'none';
        }

        function animatePlayer() {
            requestAnimationFrame(animatePlayer);
            if (audioPlayer.paused) return; 
            drawDynamicBackground();
            // Extra safeguard ‑ update subtitles every frame for tighter sync
            updateSubtitles();
        }

        // --- 4. PLAYBACK & SETTINGS CONTROLS ---
        playPauseBtn.addEventListener('click', () => {
            console.log("Play/Pause button clicked.");
            if (!isReadyToPlay) return;
            if (!audioContext) setupAudioContext();
            if (audioContext.state === 'suspended') audioContext.resume();
            audioPlayer.paused ? audioPlayer.play() : audioPlayer.pause();
        });
        
        resetBtn.addEventListener('click', () => { 
            console.log("Reset button clicked.");
            audioPlayer.currentTime = 0; 
        });
        settingsBtn.addEventListener('click', () => {
            console.log("Settings button clicked.");
            settingsModal.classList.remove('hidden');
        });
        closeSettingsBtn.addEventListener('click', () => {
            console.log("Close Settings button clicked.");
            settingsModal.classList.add('hidden');
        });
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                console.log("Clicked outside settings modal.");
                settingsModal.classList.add('hidden');
            }
        });
        
        progressBarContainer.addEventListener('click', function(e) {
            console.log("Progress bar clicked.");
            if (!audioPlayer.duration) return;
            
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const width = rect.width;
            
            // Check if we're in RTL mode
            const isRTL = settings.rtlEnabled || document.body.dir === 'rtl' || controlsContainer.dir === 'rtl';
            
            let percentage;
            if (isRTL) {
                // In RTL mode, calculate from right edge
                percentage = (width - x) / width;
            } else {
                // In LTR mode, calculate from left edge (normal)
                percentage = x / width;
            }
            
            // Ensure percentage is within bounds
            percentage = Math.max(0, Math.min(1, percentage));
            
            console.log(`Progress bar click: ${isRTL ? 'RTL' : 'LTR'} mode, x=${x}, width=${width}, percentage=${percentage.toFixed(3)}`);
            
            audioPlayer.currentTime = audioPlayer.duration * percentage;
        });

        advancedModeToggle.addEventListener('click', () => {
            console.log("Advanced Mode toggle clicked.");
            settings.advancedModeEnabled = !settings.advancedModeEnabled;
            updateToggleUI(advancedModeToggle, settings.advancedModeEnabled);
            toggleAdvancedMode(settings.advancedModeEnabled);
        });

        closeAdvancedModeBtn.addEventListener('click', () => {
            console.log("Close Advanced Mode button clicked.");
               settings.advancedModeEnabled = false;
               updateToggleUI(advancedModeToggle, false);
               toggleAdvancedMode(false);
        });
        
        function toggleAdvancedMode(enabled) {
            if (enabled) {
                // Stop demo mode when advanced mode is enabled
                if (settings.demoModeEnabled) {
                    settings.demoModeEnabled = false;
                    updateToggleUI(demoModeToggle, false);
                    stopDemoMode();
                }
                
                advancedModePanel.classList.remove('hidden');
                requestAnimationFrame(() => {
                    playerWrapper.classList.remove('w-full', 'max-w-lg');
                    playerWrapper.classList.add('w-1/2', 'max-w-none');
                    advancedModePanel.classList.remove('w-0','-translate-x-full');
                    advancedModePanel.classList.add('w-1/2', 'flex');
                    
                    updateMonacoEditorContent(); // Ensure editor content is correct on opening
                    if(monacoEditor) monacoEditor.focus();
                });
                settingsModal.classList.add('hidden');
            } else {
                // When disabling advanced mode, explicitly update the editor to show the full VTT
                // derived from the potentially modified rawVTTContent.
                if (monacoEditor) {
                    monacoEditor.setValue(rawVTTContent); // Ensure editor has full content when exiting focus mode
                }

                playerWrapper.classList.add('w-full', 'max-w-lg');
                playerWrapper.classList.remove('w-1/2', 'max-w-none');
                advancedModePanel.classList.add('-translate-x-full','w-0');
                advancedModePanel.classList.remove('w-1/2','flex');
                setTimeout(() => {
                   if (!settings.advancedModeEnabled) {
                        advancedModePanel.classList.add('hidden');
                   }
                }, 500);
            }
        }
        
        focusModeToggle.addEventListener('click', () => {
               console.log("Focus Mode toggle clicked.");
               
               // Save any pending changes before switching modes
               if (isUserTyping) {
                   isUserTyping = false;
                   if (typingTimeout) {
                       clearTimeout(typingTimeout);
                   }
               }
               
               settings.focusModeEnabled = !settings.focusModeEnabled;
               updateToggleUI(focusModeToggle, settings.focusModeEnabled);
               
               // Force update of editor content after mode change
               setTimeout(() => {
                   updateMonacoEditorContent();
               }, 50); // Small delay to ensure UI has updated
        });

        kineticToggle.addEventListener('click', () => {
            console.log("Kinetic Effects toggle clicked.");
            settings.kineticEnabled = !settings.kineticEnabled;
            updateToggleUI(kineticToggle, settings.kineticEnabled);
            updateSubtitles();
        });

        imageToggle.addEventListener('click', () => {
            console.log("Show Images toggle clicked.");
            settings.imagesEnabled = !settings.imagesEnabled;
            updateToggleUI(imageToggle, settings.imagesEnabled);
            updateSubtitles();
        });

        rtlToggle.addEventListener('click', () => {
            console.log("RTL Mode toggle clicked.");
            settings.rtlEnabled = !settings.rtlEnabled;
            applyRtlMode();
            updateToggleUI(rtlToggle, settings.rtlEnabled);
            if(settings.rtlEnabled){
                fontSelect.value = "'IBM Plex Sans Arabic', sans-serif";
            } else {
                fontSelect.value = "Inter";
            }
            settings.fontFamily = fontSelect.value;
            subtitleContainer.style.fontFamily = settings.fontFamily;
            updateMonacoEditorContent(); // Update editor content when RTL is toggled
        });

        demoModeToggle.addEventListener('click', () => {
            console.log("Demo Mode toggle clicked.");
            settings.demoModeEnabled = !settings.demoModeEnabled;
            updateToggleUI(demoModeToggle, settings.demoModeEnabled);
            
            if (settings.demoModeEnabled) {
                startDemoMode();
            } else {
                stopDemoMode();
            }
        });

        highlightOffsetSlider.addEventListener('input', (e) => {
            settings.highlightOffset = parseFloat(e.target.value);
            highlightOffsetText.textContent = `${settings.highlightOffset.toFixed(2)}s`;
        });
        highlightPacingSlider.addEventListener('input', (e) => {
            settings.highlightPacing = parseFloat(e.target.value);
            highlightPacingText.textContent = `${settings.highlightPacing.toFixed(2)}x`;
        });
        fontSelect.addEventListener('change', (e) => {
            settings.fontFamily = e.target.value;
            subtitleContainer.style.fontFamily = settings.fontFamily;
        });
        fontSizeSlider.addEventListener('input', (e) => {
            settings.fontSize = parseInt(e.target.value);
            fontSizeText.textContent = `${settings.fontSize}px`;
            subtitleContainer.style.fontSize = `${settings.fontSize}px`;
        });
        bgBlurSlider.addEventListener('input', (e) => {
            settings.backgroundBlur = parseInt(e.target.value);
            bgBlurText.textContent = `${settings.backgroundBlur}px`;
        });


        audioPlayer.onplay = () => {
            console.log("Audio started playing - updating to pause icon");
            document.getElementById('playIcon').classList.add('hidden');
            document.getElementById('pauseIcon').classList.remove('hidden');
            animatePlayer();
        };
        
        audioPlayer.onpause = () => {
            console.log("Audio paused - updating to play icon");
            document.getElementById('playIcon').classList.remove('hidden');
            document.getElementById('pauseIcon').classList.add('hidden');
        };
        audioPlayer.onloadedmetadata = () => updateTimeDisplay();
        audioPlayer.ontimeupdate = () => {
            updateTimeDisplay();
            updateSubtitles();
            if(audioPlayer.duration) {
                const percentage = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                progressBar.style.width = `${percentage}%`;
            }
        };
        
        function updateTimeDisplay() {
            const formatTime = (time) => {
                const minutes = Math.floor(time / 60).toString().padStart(2, '0');
                const seconds = Math.floor(time % 60).toString().padStart(2, '0');
                return `${minutes}:${seconds}`;
            }
            const duration = isNaN(audioPlayer.duration) ? 0 : audioPlayer.duration;
            timeDisplay.textContent = `${formatTime(audioPlayer.currentTime)} / ${formatTime(duration)}`;
        }
        
        function updateSubtitles() {
            if (!subtitles.length) return;
            const currentTime = audioPlayer.currentTime;
            const currentCue = subtitles.find(cue => currentTime >= cue.start && currentTime <= cue.end);
            
            // Create a unique ID for the current cue to track changes
            const currentCueId = currentCue ? `${currentCue.start}-${currentCue.end}` : null;
            const activeCueChanged = currentCueId !== previousActiveCueId;
            
            // Always keep track of the active cue for focus mode
            activeCueForFocusMode = currentCue;

            // Update Monaco editor content only when advanced mode is enabled and when necessary
            if (monacoEditor && settings.advancedModeEnabled) {
                // Only update editor if active cue changed or if not in focus mode
                if (activeCueChanged || !settings.focusModeEnabled) {
                    updateMonacoEditorContent();
                }
            }

            // Update the previous cue ID for next comparison
            previousActiveCueId = currentCueId;

            if (currentCue) {
                if(currentCue.mood) {
                    const preset = moodPresets[currentCue.mood.name] || moodPresets.default;
                    currentMood = {
                        palette: preset.palette,
                        frequency: currentCue.mood.frequency !== null ? currentCue.mood.frequency : preset.frequency
                    };
                }

                const hasImage = currentCue.words.some(w => w.type === 'image');
                
                brandPodviewer.style.opacity = hasImage ? '0' : '1';
                brandPodcastBy.style.opacity = hasImage ? '0' : '0.7';

                if (hasImage && settings.imagesEnabled) {
                    subtitleContainer.style.opacity = '0';
                    const imageData = currentCue.words.find(w => w.type === 'image');
                    const imageSrc = pastedImages[imageData.src] || imageData.src;

                    // Hide container while new image loads to prevent showing old frame
                    imageContainer.style.opacity = '0';

                    if (imageData) {
                         // Set up onload handler before changing src
                         cueImage.onload = () => {
                             // Only reveal once the correct image is fully loaded
                             imageContainer.style.opacity = '1';
                         };

                         // Force load even if same src (e.g., repeated cue) by clearing first
                         if (cueImage.src !== imageSrc) {
                           cueImage.src = imageSrc;
                         } else {
                             // Image unchanged – reveal immediately
                    imageContainer.style.opacity = '1';
                         }
                     }

                     /* --- Apply kinetic / sizing rules for image effects --- */
                     cueImage.className = 'w-full h-full object-contain rounded-lg shadow-lg';

                     if (settings.kineticEnabled && imageData.effects && imageData.effects.animation) {
                         const cueDuration = currentCue.end - currentCue.start;
                         cueImage.style.animationDuration = `${cueDuration}s`;
                         cueImage.style.setProperty('--cue-duration', `${cueDuration}s`);
                        cueImage.classList.add(`fx-image-${imageData.effects.animation}`);

                         // Position adjustments for edge-style effects
                         if (['edge', 'edge-talk'].includes(imageData.effects.animation)) {
                             imageContainer.style.justifyContent = 'flex-end';
                             imageContainer.style.alignItems = 'flex-start';
                             cueImage.style.width = '';
                             cueImage.style.height = '';
                             cueImage.style.maxWidth = '150px';
                             cueImage.style.maxHeight = '150px';
                    } else {
                             imageContainer.style.justifyContent = 'center';
                             imageContainer.style.alignItems = 'center';
                             cueImage.style.width = '100%';
                             cueImage.style.height = 'auto';
                             cueImage.style.maxWidth = '';
                             cueImage.style.maxHeight = '';
                         }
                     } else {
                         // No kinetic effect
                        cueImage.style.animationName = '';
                         imageContainer.style.justifyContent = 'center';
                         imageContainer.style.alignItems = 'center';
                         cueImage.style.width = '100%';
                         cueImage.style.height = 'auto';
                         cueImage.style.maxWidth = '';
                         cueImage.style.maxHeight = '';
                     }
                } else {
                     // Ensure previous image is hidden and cleared when switching back to text
                    imageContainer.style.opacity = '0';
                     cueImage.onload = null;
                     // Optional: clear src so the old image won't flash later
                     cueImage.src = '';
                    subtitleContainer.style.opacity = '1';

                    const words = currentCue.words.filter(w => w.type === 'text');
                    const cueDuration = currentCue.end - currentCue.start;
                    
                    if (cueDuration <= 0 || words.length === 0) {
                        subtitleLine.innerHTML = words.map(w => w.text || '').join(' ');
                        return;
                    }

                    // Check if any word has typing effect
                    const hasTypingEffect = words.some(word => word.effects && word.effects.animation === 'typing');
                    
                    if (hasTypingEffect) {
                        console.log("Typing effect detected for cue:", currentCue.originalText);
                        console.log("Words with effects:", words.map(w => ({ text: w.text, effects: w.effects })));
                        
                        // Handle typing effect for entire cue
                        const timeIntoCue = (currentTime - currentCue.start) + settings.highlightOffset;
                        const progressRatio = Math.max(0, timeIntoCue / cueDuration);
                        const pacedProgress = Math.pow(progressRatio, settings.highlightPacing);
                        
                        // Calculate total characters in the cue
                        const fullText = words.map(w => w.text).join(' ');
                        const totalChars = fullText.length;
                        const charsToShow = Math.floor(pacedProgress * totalChars);
                        
                        console.log(`Typing progress: ${charsToShow}/${totalChars} chars (${(pacedProgress * 100).toFixed(1)}%)`);
                        
                        // Build the revealed text character by character
                        let charCount = 0;
                        let wordElements = [];
                        
                        for (let i = 0; i < words.length; i++) {
                            const word = words[i];
                            let wordContent = '';
                            let wordStyle = '';
                            let wordClasses = '';
                            
                            // Apply ALL effects if present (not just color)
                            if (settings.kineticEnabled && word.effects) {
                                if (word.effects.color) {
                                    wordStyle = `color: ${word.effects.color};`;
                                }
                                // Apply non-typing effects as classes
                                if (word.effects.animation && word.effects.animation !== 'typing') {
                                    wordClasses = `is-highlighted fx-${word.effects.animation}`;
                                }
                            }
                            
                            // Calculate how many characters of this word to show
                            const wordStartChar = charCount;
                            const wordEndChar = charCount + word.text.length;
                            const spaceChar = i < words.length - 1 ? 1 : 0; // Add space except for last word
                            
                            if (charsToShow > wordStartChar) {
                                const charsInThisWord = Math.min(charsToShow - wordStartChar, word.text.length);
                                wordContent = word.text.substring(0, charsInThisWord);
                                
                                // Add typing cursor if we're in the middle of this word AND it has typing effect
                                if (word.effects && word.effects.animation === 'typing' && 
                                    charsInThisWord < word.text.length && charsToShow >= wordStartChar && charsToShow < wordEndChar) {
                                    wordContent += '<span class="typing-cursor">|</span>';
                                }
                            }
                            
                            if (wordContent) {
                                wordElements.push(`<span class="${wordClasses}" style="${wordStyle}">${wordContent}</span>`);
                            }
                            
                            charCount += word.text.length + spaceChar;
                            
                            // Add space if we've revealed it and this isn't the last word
                            if (spaceChar && charsToShow > wordEndChar) {
                                wordElements.push(' ');
                            } else if (spaceChar && charsToShow === wordEndChar + 1) {
                                // Show typing cursor at space position only if current word has typing effect
                                if (word.effects && word.effects.animation === 'typing') {
                                    wordElements.push('<span class="typing-cursor">|</span>');
                                } else {
                                    wordElements.push(' ');
                                }
                                break;
                            }
                        }
                        
                        subtitleLine.innerHTML = wordElements.join('');
                    } else {
                        // Handle normal effects (non-typing)
                        const timeIntoCue = (currentTime - currentCue.start) + settings.highlightOffset;
                        const progressRatio = Math.max(0, timeIntoCue / cueDuration);
                        const pacedProgress = Math.pow(progressRatio, settings.highlightPacing);

                        // Word-level highlighting again. If several consecutive words share the *same object* for
                        // `effects` (because they came from the same <fx:…> wrapper) we treat them as a mini-group
                        // and highlight them together – this keeps phrases like "Apple Inc" pulsing together while
                        // still letting the caret move word-by-word across plain text.

                        const highlightWordIndex = Math.floor(pacedProgress * words.length);
                        const htmlParts = [];

                        words.forEach((word, index) => {
                            const prevEffectsObj = index > 0 ? words[index - 1].effects : null;
                            const sameAsPrev = prevEffectsObj === word.effects; // object reference equality on purpose
                            // If this word shares an effects object with the previous one, use the *same* highlight
                            // status so the phrase animates together. Otherwise highlight strictly by index.
                            const isHighlighted = sameAsPrev ? (index - 1) === highlightWordIndex : index === highlightWordIndex;
                                 let style = '';
                                 let classes = isHighlighted ? 'is-highlighted' : 'text-dim';
                                 let content = word.text;
                                 // DEBUG
                                 console.log(`Word: "${word.text}", isHighlighted: ${isHighlighted}, effects:`, word.effects, `kineticEnabled: ${settings.kineticEnabled}`);

                                 if (settings.kineticEnabled && word.effects) {
                                     if (word.effects.color) {
                                         style += `color: ${word.effects.color};`;
                                         console.log(`Applied color: ${word.effects.color}`);
                                     }

                                     // Apply animation classes when the GROUP is highlighted (not per-word)
                                     if (word.effects.animation) {
                                         console.log(`Processing animation: ${word.effects.animation} for word: ${word.text}`);
                                         if (word.effects.animation.startsWith('emoji-rain')) {
                                             // Extract emoji from effect name (e.g., "emoji-rain:🔥" or "emoji-rain:😂,0.5")
                                             const parts = word.effects.animation.split(':');
                                             if (parts.length > 1) {
                                                 const emojiParts = parts[1].split(',');
                                                 const emoji = emojiParts[0] || '🔥';
                                                 
                                                 console.log(`Applying emoji storm effect with emoji: ${emoji}`);
                                                 
                                                 // Create or get storm container within subtitle area
                                                 let stormContainer = subtitleContainer.querySelector('.emoji-storm-container');
                                                 if (!stormContainer) {
                                                     stormContainer = document.createElement('div');
                                                     stormContainer.className = 'emoji-storm-container';
                                                     stormContainer.setAttribute('data-emoji', emoji);
                                                     subtitleContainer.appendChild(stormContainer);
                                                     
                                                     // Create fast emoji particles for quick word-duration effect
                                                     for (let i = 0; i < 50; i++) {
                                                         const particle = document.createElement('div');
                                                         particle.className = 'emoji-storm-particle';
                                                         particle.textContent = emoji;
                                                         
                                                         // Full width distribution for subtitle area coverage
                                                         const basePosition = (i * 2) % 100;
                                                         particle.style.left = basePosition + (Math.random() * 6 - 3) + '%';
                                                         
                                                         // Fast, immediate delays for word-duration timing
                                                         const baseDelay = (i * 0.02) % 0.8;
                                                         particle.style.animationDelay = (baseDelay + Math.random() * 0.2) + 's';
                                                         
                                                         // Start from above subtitle area, with varied heights
                                                         particle.style.top = (Math.random() * -80 - 20) + 'px';
                                                         
                                                         // Ensure particles reach through full subtitle height
                                                         const baseDuration = parseFloat(getComputedStyle(particle).animationDuration) || 0.5;
                                                         particle.style.animationDuration = (baseDuration + Math.random() * 0.2 - 0.1) + 's';
                                                         
                                                         stormContainer.appendChild(particle);
                                                     }
                                                 }
                                                 
                                                 // Just highlight the word normally
                                                 classes = isHighlighted ? 'is-highlighted' : '';
                                                 
                                                 console.log(`Applied emoji storm background effect: ${emoji}`);
                                             } else {
                                                 // Fallback if no emoji specified
                                                 classes += ' fx-emoji-rain';
                                             }
                                         } else if (isHighlighted && word.effects.animation === 'wave') {
                                             classes += ' fx-wave';
                                             content = word.text.split('').map((char, charIndex) =>
                                                 `<span style="animation-delay: ${charIndex * 0.05}s">${char}</span>`
                                             ).join('');
                                             console.log('Applied wave effect');
                                         } else if (isHighlighted && word.effects.animation !== 'wave') {
                                             classes += ` fx-${word.effects.animation}`;
                                             console.log(`Applied animation class: fx-${word.effects.animation}`);
                                         }
                                     }

                                     if (word.effects.animation === 'wave') {
                                         classes += ' fx-wave';
                                         content = word.text.split('').map((char, charIndex) =>
                                             `<span style="animation-delay: ${charIndex * 0.05}s">${char}</span>`
                                         ).join('');
                                         console.log('Applied wave effect');
                                     }
                                 }

                                 htmlParts.push(`<span class="${classes}" style="${style}">${content}</span>`);
                                 // Add normal space between words (except after last word)
                                 if (index < words.length - 1) htmlParts.push(' ');
                        });

                        subtitleLine.innerHTML = htmlParts.join('');
                        
                        // Check if current cue has any emoji rain effects, remove storm if not
                        const hasEmojiRain = words.some(word => 
                            word.effects && word.effects.animation && word.effects.animation.startsWith('emoji-rain')
                        );
                        
                        if (!hasEmojiRain) {
                            const stormContainer = subtitleContainer.querySelector('.emoji-storm-container');
                            if (stormContainer) {
                                stormContainer.remove();
                            }
                        }
                    }
                }
            } else {
                subtitleLine.innerHTML = '';
                imageContainer.style.opacity = '0';
                         
                         // Remove any background scene effects when no cue is active
                         subtitleContainer.classList.remove('bg-matrix', 'bg-retro-grid');
                         
                         // Remove emoji storm when no cue is active
                         const stormContainer = subtitleContainer.querySelector('.emoji-storm-container');
                         if (stormContainer) {
                             stormContainer.remove();
                         }
                     }
                     
                     // Handle background scene switches
                     if (currentCue && currentCue.backgroundScene) {
                         subtitleContainer.classList.remove('bg-matrix', 'bg-retro-grid');
                         subtitleContainer.classList.add(currentCue.backgroundScene);
            }
        }

        // --- New function to update Monaco Editor content ---
        function updateMonacoEditorContent() {
            if (!monacoEditor || !settings.advancedModeEnabled) {
                // If editor not initialized or advanced mode is off, do nothing
                return;
            }

            // Don't update editor content if user is currently typing
            if (isUserTyping) {
                return;
            }

            // Set the editor's text direction based on settings.rtlEnabled
            monacoEditor.getModel().setEOL(monaco.editor.EndOfLinePreference.LF); // Ensure consistent EOL
            monacoEditor.updateOptions({ 'wordSeparators': settings.rtlEnabled ? ' \t\n\r"\'`~!@#$%^&*()-=+[{]}\\|;:,.<>/?' : null }); // Adjust word separators for RTL

            if (settings.focusModeEnabled) {
                let focusContent = "No active cue.";
                if (activeCueForFocusMode) {
                    focusContent = activeCueForFocusMode.originalText;
                }
                // Check if current value is different to avoid unnecessary updates and cursor jumps
                if (monacoEditor.getValue() !== focusContent) {
                    // Store cursor position before update
                    const position = monacoEditor.getPosition();
                    monacoEditor.setValue(focusContent);
                    // Try to restore cursor position if it's still valid
                    try {
                        if (position && position.lineNumber <= monacoEditor.getModel().getLineCount()) {
                            monacoEditor.setPosition(position);
                        }
                    } catch (e) {
                        // If position restore fails, just put cursor at end
                        monacoEditor.setPosition(monacoEditor.getModel().getFullModelRange().getEndPosition());
                    }
                    monacoEditor.setScrollPosition({ scrollTop: 0 });
                    editorDecorations = monacoEditor.deltaDecorations(editorDecorations, []); // Clear highlights in focus mode
                    lastRevealedLine = -1;
                }
            } else {
                // Not in focus mode, show full VTT content
                if (monacoEditor.getValue() !== rawVTTContent) {
                    // Store cursor position before update
                    const position = monacoEditor.getPosition();
                    monacoEditor.setValue(rawVTTContent);
                    // Try to restore cursor position if it's still valid
                    try {
                        if (position && position.lineNumber <= monacoEditor.getModel().getLineCount()) {
                            monacoEditor.setPosition(position);
                        }
                    } catch (e) {
                        // Position restore failed, keep default position
                    }
                }
                // Highlight current cue in full VTT editor
                if(activeCueForFocusMode && activeCueForFocusMode.lineNumber !== lastRevealedLine) {
                    monacoEditor.revealLineInCenter(activeCueForFocusMode.lineNumber, monaco.editor.ScrollType.Smooth);
                    editorDecorations = monacoEditor.deltaDecorations(editorDecorations, [{
                        range: new monaco.Range(activeCueForFocusMode.lineNumber, 1, activeCueForFocusMode.lineNumber + 2, 1),
                        options: { isWholeLine: true, className: 'current-cue-highlight', inlineClassName: 'bg-purple-500/20' }
                    }]);
                    lastRevealedLine = activeCueForFocusMode.lineNumber;
                } else if (!activeCueForFocusMode) {
                    editorDecorations = monacoEditor.deltaDecorations(editorDecorations, []);
                    lastRevealedLine = -1;
                }
            }
             // Ensure the editor's view is updated to reflect the new direction
            monacoEditor.layout();
        }
        
        // --- 5. INITIALIZATION ---
        function updateToggleUI(toggleElement, isEnabled){
              const handle = toggleElement.querySelector('span:not(.sr-only)');
              if (isEnabled) {
                toggleElement.classList.remove('bg-gray-600');
                toggleElement.classList.add('bg-purple-600');
                handle.classList.add('translate-x-5');
                handle.classList.remove('translate-x-0');
            } else {
                toggleElement.classList.add('bg-gray-600');
                toggleElement.classList.remove('bg-purple-600');
                handle.classList.remove('translate-x-5');
                handle.classList.add('translate-x-0');
            }
        }

        function applyRtlMode() {
            const isRtl = settings.rtlEnabled;
            subtitleContainer.dir = isRtl ? 'rtl' : 'ltr';
            controlsContainer.dir = isRtl ? 'rtl' : 'ltr';

            // NEW: Keep the editor panel LTR no matter what
            advancedModePanel.setAttribute('dir', 'ltr');
            monacoEditorContainer.style.direction = 'ltr'; // Ensure container itself is LTR

            // (If you really must flip the whole <body>, do it *after*
            // the two lines above, then call layout again:)
            // document.body.dir = isRtl ? 'rtl' : 'ltr';

            // Force a layout update after changing direction properties
            if (monacoEditor) {
                monacoEditor.layout();
            }
        }
        
        function initializeSettings() {
            updateToggleUI(advancedModeToggle, settings.advancedModeEnabled);
            updateToggleUI(focusModeToggle, settings.focusModeEnabled);
            updateToggleUI(kineticToggle, settings.kineticEnabled);
            updateToggleUI(imageToggle, settings.imagesEnabled);
            updateToggleUI(rtlToggle, settings.rtlEnabled);
                     updateToggleUI(demoModeToggle, settings.demoModeEnabled);
            applyRtlMode();
            highlightOffsetSlider.value = settings.highlightOffset;
            highlightOffsetText.textContent = `${settings.highlightOffset.toFixed(2)}s`;
            highlightPacingSlider.value = settings.highlightPacing;
            highlightPacingText.textContent = `${settings.highlightPacing.toFixed(2)}x`;
            fontSelect.value = settings.fontFamily;
            subtitleContainer.style.fontFamily = settings.fontFamily;
            fontSizeSlider.value = settings.fontSize;
            fontSizeText.textContent = `${settings.fontSize}px`;
            subtitleContainer.style.fontSize = `${settings.fontSize}px`;
            bgBlurSlider.value = settings.backgroundBlur;
            bgBlurText.textContent = `${settings.backgroundBlur}px`;
        }
        
        function resizeAllCanvases() {
            const canvas = backgroundCanvas;
            try {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
            } catch (e) {
                console.error("Error resizing canvas:", e);
            }
        }
        
        // --- MONACO EDITOR SETUP ---
        require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.41.0/min/vs' }});
        window.MonacoEnvironment = {
            getWorkerUrl: function (moduleId, label) {
                // Ensure absolute paths for Monaco Editor workers
                const cdnBase = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.41.0/min/vs';
                if (label === 'json') return `${cdnBase}/language/json/json.worker.js`;
                if (label === 'css' || label === 'scss' || label === 'less') return `${cdnBase}/language/css/css.worker.js`;
                if (label === 'html' || label === 'handlebars' || label === 'razor') return `${cdnBase}/language/html/html.worker.js`;
                if (label === 'typescript' || label === 'javascript') return `${cdnBase}/language/typescript/ts.worker.js`;
                return `${cdnBase}/editor/editor.worker.js`;
            }
        };

        require(['vs/editor/editor.main'], function() {
            monaco.editor.defineTheme('podviewer-dark', {
                base: 'vs-dark',
                inherit: true,
                rules: [
                    { token: 'comment', foreground: '6a9955' }, 
                    { token: 'metatag', foreground: 'c586c0' }, 
                    { token: 'tag', foreground: '4ec9b0' },
                    { token: 'attribute.name', foreground: '9cdcfe' },
                    { token: 'attribute.value', foreground: 'ce9178' },
                ],
                colors: {
                    'editor.background': '#1e1e1e'
                }
            });
            
            monacoEditor = monaco.editor.create(monacoEditorContainer, {
                value: rawVTTContent,
                language: 'plaintext',
                theme: 'podviewer-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                wordWrap: 'on',
                padding: { top: 16, bottom: 16 },
                scrollbar: {
                    vertical: 'auto',
                    horizontal: 'auto'
                }
            });

            monacoEditor.onDidChangeModelContent(() => {
                // Mark that user is typing
                isUserTyping = true;
                
                // Clear any existing timeout
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                }

                // Set timeout to mark typing as finished after user stops typing
                typingTimeout = setTimeout(() => {
                    isUserTyping = false;
                }, 500); // 500ms delay after last keystroke

                if (settings.focusModeEnabled) {
                    if (activeCueForFocusMode) {
                        // Get the *edited* text from the focus mode editor
                        const newCueText = monacoEditor.getValue();

                        // Only update if the text actually changed
                        if (activeCueForFocusMode.originalText !== newCueText) {
                            // Update the originalText for the currently active cue object in the subtitles array
                            activeCueForFocusMode.originalText = newCueText;

                            // Only reconstruct and re-parse if we need to update other parts of the system
                            // For immediate visual feedback, we can parse just this cue
                            const tempVTT = `WEBVTT\n\n${formatTime(activeCueForFocusMode.start)} --> ${formatTime(activeCueForFocusMode.end)}\n${newCueText}`;
                            const tempCues = parseVTTWithEffects(tempVTT);
                            
                            if (tempCues.length > 0) {
                                // Update the words and mood for the current cue without full re-parsing
                                activeCueForFocusMode.words = tempCues[0].words;
                                activeCueForFocusMode.mood = tempCues[0].mood;
                            }

                            // Defer the full VTT reconstruction to reduce frequency
                            clearTimeout(window.vttUpdateTimeout);
                            window.vttUpdateTimeout = setTimeout(() => {
                                rawVTTContent = serializeVTT(subtitles);
                                // Only do full re-parse if not currently typing
                                if (!isUserTyping) {
                                    subtitles = parseVTTWithEffects(rawVTTContent);
                                }
                            }, 250); // Debounce VTT updates

                            // Call updateSubtitles immediately for visual feedback in the player
                            // But don't update the editor content since we're in the middle of editing
                            const wasUserTyping = isUserTyping;
                            updateSubtitles();
                            isUserTyping = wasUserTyping; // Restore typing state
                        }
                    }
                } else {
                    // If not in focus mode, the editor holds the entire VTT content
                    const newVTTContent = monacoEditor.getValue();
                    if (rawVTTContent !== newVTTContent) {
                        rawVTTContent = newVTTContent;
                        
                        // Debounce full re-parsing for efficiency
                        clearTimeout(window.fullParseTimeout);
                        window.fullParseTimeout = setTimeout(() => {
                            subtitles = parseVTTWithEffects(rawVTTContent);
                            const wasUserTyping = isUserTyping;
                            updateSubtitles();
                            isUserTyping = wasUserTyping; // Restore typing state
                        }, 300);
                    }
                }
            });
            
            editorImageUploadInput.addEventListener('change', (e) => {
                console.log("Upload Image input change detected.");
                if (e.target.files.length === 0) {
                    console.log("Image upload cancelled or no file selected.");
                    return;
                }
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(event) {
                    const base64data = event.target.result;
                    const imageName = `uploaded_image_${Date.now()}.${file.name.split('.').pop()}`;
                    pastedImages[imageName] = base64data; // Store base64 data for image display
                    
                    const imageTag = `<img:${imageName}>`;

                    const position = monacoEditor.getPosition();
                    monacoEditor.executeEdits('insert-image', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: imageTag,
                        forceMoveMarkers: true
                    }]);
                    console.log(`Image uploaded: ${imageName}. Tag inserted.`);
                    // After inserting text, onDidChangeModelContent will handle the update to subtitles/rawVTTContent
                    updateSubtitles(); // Trigger player update immediately
                };
                reader.readAsDataURL(file);
                e.target.value = ''; // Clear input to allow re-uploading the same file
            });

            // New: Event listener for paste button with robust fallbacks
            pasteImageBtn.addEventListener('click', async () => {
                console.log("Paste Image button clicked.");
                if (!monacoEditor) return;

                // Check if we're in a secure context first
                const isSecureContext = window.isSecureContext || location.protocol === 'https:';
                
                if (!isSecureContext) {
                    console.warn("Not in secure context - clipboard API limited");
                    showPasteInstructions();
                    return;
                }

                try {
                    // Try modern Clipboard API first
                    if (navigator.clipboard && navigator.clipboard.read) {
                        console.log("Using modern Clipboard API");
                        const clipboardItems = await navigator.clipboard.read();
                        
                        for (const clipboardItem of clipboardItems) {
                            const imageTypes = clipboardItem.types.filter(type => type.startsWith('image/'));
                            
                            if (imageTypes.length > 0) {
                                const imageType = imageTypes[0];
                                const blob = await clipboardItem.getType(imageType);
                                await processImageBlob(blob, imageType);
                                return;
                            }
                        }
                        
                        showNoImageMessage();
                        return;
                    }
                } catch (error) {
                    console.error("Modern Clipboard API failed:", error);
                }

                // Fallback to legacy approach
                showPasteInstructions();
            });

            // Helper function to show paste instructions
            function showPasteInstructions() {
                console.log("Using manual paste instruction method");
                
                // Create a more visible notification
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-purple-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 flex items-center gap-3';
                notification.innerHTML = `
                             <i data-lucide="clipboard" class="w-5 h-5"></i>
                    <span>Click in the editor below, then press <strong>Ctrl+V</strong> (or <strong>Cmd+V</strong>) to paste image</span>
                    <button onclick="this.parentElement.remove()" class="ml-2 text-white/80 hover:text-white">✕</button>
                `;
                document.body.appendChild(notification);
                         
                         // Initialize Lucide icons in the notification
                         if (typeof lucide !== 'undefined') {
                             lucide.createIcons();
                         }
                
                // Focus the editor
                monacoEditor.focus();
                
                // Auto-remove notification after 8 seconds
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 8000);
            }

            // Helper function to show no image message
            function showNoImageMessage() {
                console.log("No image found in clipboard.");
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-orange-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 flex items-center gap-3';
                notification.innerHTML = `
                             <i data-lucide="triangle-alert" class="w-5 h-5"></i>
                    <span>No image found in clipboard. Copy an image first!</span>
                    <button onclick="this.parentElement.remove()" class="ml-2 text-white/80 hover:text-white">✕</button>
                `;
                document.body.appendChild(notification);
                         
                         // Initialize Lucide icons in the notification
                         if (typeof lucide !== 'undefined') {
                             lucide.createIcons();
                         }
                
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 4000);
            }

            // Helper function to process image blob
            async function processImageBlob(blob, imageType) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64data = e.target.result;
                    const imageName = `pasted_image_${Date.now()}.${imageType.split('/')[1]}`;
                    pastedImages[imageName] = base64data;
                    
                    const position = monacoEditor.getPosition();
                    monacoEditor.executeEdits('insert-image', [{
                        range: new monaco.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                        text: `<img:${imageName}>`,
                        forceMoveMarkers: true
                    }]);
                    
                    console.log(`Image pasted successfully: ${imageName}`);
                    showSuccessMessage();
                    updateSubtitles();
                };
                reader.readAsDataURL(blob);
            }

            // Helper function to show success message
            function showSuccessMessage() {
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 flex items-center gap-3';
                notification.innerHTML = `
                             <i data-lucide="check" class="w-5 h-5"></i>
                    <span>Image pasted successfully!</span>
                `;
                document.body.appendChild(notification);
                         
                         // Initialize Lucide icons in the notification
                         if (typeof lucide !== 'undefined') {
                             lucide.createIcons();
                         }
                
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 3000);
            }

            // New: Universal paste event listener for the editor container (for Ctrl+V / Cmd+V)
            monacoEditorContainer.addEventListener('paste', (event) => {
                console.log("Paste event detected on editor container.");
                const items = (event.clipboardData || event.originalEvent.clipboardData).items;
                let imageFound = false;
                
                for (const item of items) {
                    if (item.kind === 'file' && item.type.startsWith('image/')) {
                        event.preventDefault(); // Prevent default paste behavior for images
                        imageFound = true;
                        const blob = item.getAsFile();
                        processImageBlob(blob, item.type);
                        break;
                    }
                }
                
                if (!imageFound) {
                    console.log("Paste event: No image found or non-image content pasted.");
                }
            });

        });
        
        window.addEventListener('resize', resizeAllCanvases);
        resizeAllCanvases();
        initializeSettings();
                 
                 // Initialize Lucide icons
                 if (typeof lucide !== 'undefined') {
                     lucide.createIcons();
                 }
    }
    </script>
</body>
</html>
